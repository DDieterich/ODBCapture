# Oracle Database Generated Self-Build

Native Script Generation of Source Code and Configuration Data

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

Duane Dieterich

DMSTEX (of Dallas County)

26-March-2024

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

## Summary

The ability to recreate a database from source code is largely deemed as unnecessary by today's developers, administrators, and project managers.  Even with the adoption of CI/CD, database source code has been relegated to change tracking engines like Liquibase and Flyway.

Anyone who has tried to create source code for a database using existing tools like Toad, PLSQL Developer, and SQL Developer is quickly met with frustration.  Too many or too few database objects get swept up in source code generation from these tools.  The additional struggle to deal with a minimum data set required to create a functioning database also becomes daunting very quickly.

ODBCapture uses the Oracle database to create complete database build scripts with all the required database objects and data.  The build scripts generated by ODBCapture can be used to create a working, functioning database.  Layering of different build scripts allow different databases to be built from the same database source code for different purposes like development, testing, and quality assurance.  ODBCapture can also create build script that support different environments.  Since they are self-generated, build scripts can also be audited and tested as valid and complete.



## What is the Problem?

**What is Source Code?**

    *"Source code (also referred to as source or code) is the version of software as it is originally written (i.e., typed into a computer) by a human in plain text (i.e., human readable alphanumeric characters)."*

    [Source Code Definition](https://www.linfo.org/source_code.html)

Every Oracle database developer knows what source code looks like.  SQL and PL/SQL are the ongoing fee requied by the database to make it work and keep it working.  However, little attention is paid to accurately capturing this source code.

Source code for a database tends to be a facade used to satisfy some need for audit, business initiative, or contract obligation.  The appearance of source code to recreate a database is more important than the ability to actually recreate the database.  Datbase source code that can't completly recreate the database is in effect a change tracking engine.

**Lack of Priority**

The lack of priority for complete and acurate database source code has impeded the development of a useful solution.

[Yalim Gerger](https://www.linkedin.com/in/yalimgerger/), Founder of Gitora, describes this situation clearly in his [Version Control for PL SQL](https://www.youtube.com/watch?v=H4yxDVnzDtc&t=141s) video (starting at 0:18).  Anecdotal evidence largely supports Yalim's experience.

   *"... version control is a difficult topic to talk about in the PL/SQL community.  Most of the time, when I open this topic, people go like 'what problem, there's no problem with version control ...'"*

**Define the Problem**

Accurate and complete database source code can be more fully understood using these capabilities.
* Recreate a specified version of a database, along with configuration data and/or test data as required for a specified environment.
* Allow CI/CD to create (pluggable) databases (from scratch) for developement and testing as part of development and release pipelines.
* Show a complete history of changes for all aspects of database source code, configuration data, and/or test data.
* Provide an audit hook to compare production source code with source code stored in version control.

**Build Script Layering**

Use of accurate and complete database source code exposes the need for source code options, or layering, when building a database.  The options/layers include the need for:
* Basic application configuration data
* Environment and/or test specific configuration data
* Source code for unit testing on a development database
* Test data for unit testing on a development database
* Source code for QA testing on a QA database
* Test data for QA testing on a QA database

Each of these options/layers needs to be assembled in a fassion that allow the resulting database to function correctly.  DDL and DML script generation must account for these options/layers and the inter-dependencies between them.

**No easy way to create database source code.**

While some development teams have created custom utilities to produce accurate and complete database source code, there is no generic tool set available  Technical limitations of commercially available tools include the requirement to use a GUI to select tables and database objects to export.

* [What is a DDL Script, and Why It Is Useful](https://blog.toadworld.com/what-is-a-ddl-script-and-why-it-is-useful) (TOAD)
    * *"The DBAs and Developers must write a script to create DDL objects ..."*
    * *"The script execution will fail if the user who is executing the script does not have appropriate permission ..."*
    * *"... make sure that tables are created in the proper sequence."*
    * *"... select Tables from the Load object type drop-down box ..."*

* [PL/SQL Developer Export User Objects](https://www.allroundautomations.com/products/pl-sql-developer/features/export-user-objects/)
    * *"After selecting the objects you wish to export ..."*
    * *"... include the grants of the object privileges to other users and roles ..."*
    * *"... the output file will contain a series of calls to these object specific files."*

* [Generate DDL Script For All Tables of a Schema in SQL Developer](https://creativeme1807.wordpress.com/2019/01/17/generate-ddl-script-for-all-tables-of-a-schema-in-sql-developer/)
    * *"... Generate DDL scripts for all tables in a schema in SQL developer, without much work."*
    * *"Go to FILE -> DATA MODELLER -> EXPORT -> DDL FILE"*
    * *"Select table you want to have DDL scripts"*

* [Source Control for Oracle](https://www.red-gate.com/products/source-control-for-oracle/) (Red-Gate)
    * *"Source Control for Oracle capabilities will be merging into Flyway"*

* [Database source control. Simplified.](https://www.dbmaestro.com/database-source-control) (DB Maestro)
    * (Unable to get documented details on functionality or pricing)

* [Version Control for PL SQL](https://www.youtube.com/watch?v=H4yxDVnzDtc&t=141s) (GitOra)
    * *"(at 2:02) A lot of people confuse the management of PL/SQL source code with the management of table structures."*
    * *"(at 2:14) ... Jova developers ... have issues managing their table structures ..."*
    * *"(at 8:03) Does GitOra manage SQL too, like the table's data changes, does GitOra create versions of them?  No ..."*

When a commercial tool is able to create them, build scripts tend to lack all the elements needed to recreate an accurate and complete database.  Also, there is no way to pre-configure these tools to generate the same set of database objects and data into the same set of build scripts without using the GUI.


## What is Needed?

As discussed in the previous section, a simple way to create accurate and complete database build scripts (source code) is needed.  Following are the details.


### Database Self-Build Scripts

Since developers use databases (not text editors) to develop, the database needs the ability to generate build scripts.  These build scripts must be able to re-create the necessary database objects, configuration data, and test data in a newly created (pluggable) database (from scratch).  Without this capability, some portion of a database must already exist, effectively limiting database source code to a change tracking engine.

**Oracle Database Specific**

Due to its complex and comprehensive nature, this solution needs to be Oracle Database specific.  A generic tool will be reduced to the lowest common demoninator, making it ineffective.

**Comprehensive**

The solution needs to handle multiple integrated users/schemas.  Many large Oracle databases have an entaglement of dependencies between schemas.  Successfully extracting a single, buildable schema from this entaglement can be very difficult.  This solution must be able to successfully install co-dependent schema simultaneously.

The solution needs to handle multiple Oracle object types.  Many sophisticated Oracle databases take advantage of the wide range of object types available in the database, like Advanced Queues.  This solution must handle a large list.

The solution needs to handle multiple Oracle data types.  Many sophisticated Oracle database take advantage of the wide range of data types in the database, like XML and BLOB.  This solution must handle a large list.


### Source Code Portability

Since the Oracle database is operating system neutral, the build scripts created by the database must be operating system neutral.  No batch or shell scripting should be allowed because each must be tailored to a specific operating system.  Since SQL-Plus and SQL-Loader are included with every database installation, build scripts should be limited to the use of those tools.

Character translation of build scripts and data files must be handled.  For the purposes of these build scripts, Big Endien (and Little Endien) issues are handled by the operating system.  Character set conversions between ASCII, UTF-8, UTF-16, EBCDIC, other are also handled by the operating system.  Character set conversion of string based files between systems is automatic during transfers.  Oracle database tools also automatically convert character sets during loading and unloading of data between the database and the operating system.

Binary data, such as images and encrypted passwords, must be converted to string based files.  There are several standard formats like HEX encoding and Base64 encoding that can be used for this purpose.


### Installation Layering

Most sophisticated Oracle databases include a variety of database objects and data.  These can include:
* Base Application Database Objects
* Base Application Configuration Data
* Development Environment Configuration Data
* Mock Database Objects for Unit Testing
* Unit Testing Database Objects
* Unit Test Data
* QA Environment Configuration Data
* QA Testing Database Objects
* QA Test Data

The solution needs to accomodate this variety of database objects and data.  The solution also needs allow for proper sequencing of these objects, including the interdependency between them.


### Source Code Organization

Given these build scripts are going into a source control system like Git, some simple guidelines should apply to the files.

Each database object should have its own script.  This allows easier tracking of changes to database objects in the source control system.

Schemas (database object owners) should have their own folders.  This futher simplifies the tracking of changes by grouping all database object files together that are owned by the same database user.

For ease of deployment security, all SYS related build scripts should be grouped together and separated from SYSTEM build scripts.  This allows database administrators to tightly scrutinize and possible limit highly permissive build scripts that require SYS privileges.



## ODBCapture Implementation

The following is a description of the ODBCapture implementation and how it complies with the needs described above.


### Standardized Oracle Utilities

DBMS_METADATA has become a popular package for creating DDL (and DCL) from an Oracle database.  The ODBCapture implementation uses DBMS_METADATA.get_ddl wherever possible to provde generic functionality for build script generation.

The DBMS_SQL package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL.  The ODBCapture implementation uses DBMS_SQL to create the comprehensive data loader (cldr) script data, typically in CSV files.


### Tool Configuration

Configuration of ODBCapture is required to accomplish the needs previously described.
* **Element** configuration is very specific and should not be modified without a thorough understanding.
* **Build Type**, and **User/Schema** configurations are the minimum required for ODBCapture to work.  At least one Build Type and one User/Schema configuration must be created.
* **Role**, **Database Object**, and **Data Load** configurations are all optional.

**Element Configuration**

The element configuration data should not be changed.  The internal operation of the build script generator relies on certain data items in this configuration.

* ELEMENT_NAME - An internal element designation used to generate build scripts.
* ELEMENT_SEQ - The sequence these elements appear in the installation build scripts.
* FILE_EXT1, FILE_EXT2, FILE_EXT3 - Build script file name extensions.
* OBJECT_TYPE - Matching databse object type from DBA_OBJECTS.

**Build Type Configuration**

At least one Build Type configuration is required to generate build scripts.  These Build Types are used to resolve dependencies between the various installation layers as needed.  It is possible for Build Types to have no relationship (not layered).

* BUILD_TYPE - Name of this Build Type.
* BUILD_TYPE_PARENT - Parent of this Build Type.  This defines the installation layers.

**User/Schema Configuration**

At least one User/Schema configuration is required to generate build scripts.  This configuration defines which database users are included in which Build Types.

* BUILD_TYPE - Name of the Duild Type.
* USERNAME - Database username.  This is the default Build Type for the user.  By default, all user objects will be generated at this Build Type.
* TABLESPACE_NAME - Default tablespace to be used when creating this user.
* TS_SIZE - User quota on the default tablespace.

**Role Configuration**

Role configuration is optional.  If the database doesn't have any roles of interest, this configration can remain empty.

* BUILD_TYPE - Name of the Build Type.
* ROLENAME - Name of the database role to generated build scripts.

**Database Object Configuration**

Database object configuration is optional.  If all database objects should be included in the default Build Type for a schema, this configuration can remain empty.

* BUILD_TYPE - Name of the Build Type.
* USERNAME - Database username.
* ELEMENT_NAME - An internal element designation used to generate build scripts.
* OBJECT_NAME_REGEXP - Limits which database objects to include in build scripts generated for this Build Type.  Objects that match this filter will not be included in the default Build Type.

**Data Load Configuration**

Data load configuration is optional.  If no data should be included in build scripts, this configuration can remain empty.

* BUILD_TYPE - Name of the Build Type.
* USERNAME - Database username.
* TABLE_NAME - Database table name with the data to include in the build scripts.
* BEFORE_SELECT_SQL - The "pre" SQL text included before of the SQL SELECT statement querying this data.
* WHERE_CLAUSE - The WHERE clause for the SQL SELECT statement querying this data.
* ORDER_BY_COLUMNS - Required list of columns that uniquely identify the data being queried.
* AFTER_ORDER_BY_SQL - The "post" SQL text included after of the SQL ORDER BY clause querying this data.


### Database Objects and Data Types

**Database Object Types Supported**

The following lists the database object types supported by ODBCapture.

* Advanced Queue
* Advanced Queue Table
* Context
* Database Link
* Database Trigger
* Directory
* Foreign Key (psuedo-object)
* Grant (psuedo-object)
* Function
* Java Source
* Index
* Materialized View
* Package Body
* Package Specification
* Procedure
* RAS ACL (psuedo-object)
* Role
* Scheduler Job
* Scheduler Program
* Scheduler Schedule
* Sequence
* Schema Trigger
* Synonym
* Table
* Table/View Trigger
* Type Body
* Type Specification
* User
* View
* XDB ACL (psuedo-object)

**Data Types Supported**

The following lists the data types supported by ODBCapture.

* BLOB
* CHAR
* CLOB
* DATE
* INTERVAL_DAY_TO_SECOND
* NUMBER
* RAW
* TIMESTAMP
* TIMESTAMP_WITH_LOCAL_TZ
* TIMESTAMP_WITH_TZ
* VARCHAR2
* XMLTYPE


### Build Script Specifications

**ZIP File Creation**

All build scripts are added to a ZIP File created in a BLOB in the "ZIP_FILES" table.  Retreival of that ZIP file can be done using one of the following.

* UTL_FILE write (using GRAB_SCRIPTS.write_scripts procedure)
* APEX GUI Application
* SQL-Developer
* Other Oracle Database Tool

**Long Line Folding**

There are a variety of line length limitations for generated scripts.  These line length limitations are observed using a variety of techniques.

* SQL-Loader Data Files
* SQL-Plus Script Files
* Windows Script Files - For Directory Creation
* Unix/Linux Script Files - For Directory Creation

**Handling of System Generated Database Objects**

There are several different database object types that are system generated by the database.  The name of these database objects are filtered and not included in the build scripts.

* Recycle Bin Object Name
* Materialized View Index Name
* PL/SQL Pipelined Type Name
* Type Specification/Body Name
* Advanced Queue View/Type Name

**Escape Special Characters**

There are limitations on special characters used for build file generation.  Each of these limitations is handled by ODBCapture.

* SQL-Plus Scripts: "@"
* Windows File Names: "<", ">", ":", """, "/", "\", "|", "?", "*"

**Dynamically Created Utility Scripts**

A set of utility scripts with specific lists of schemas and/or database objects is needed for successful and complete installation of database objects and data.  ODBCapture custom generates these scripts as needed in the root folder of the ZIP file.

* alter_foreign_keys
* alter_queues
* alter_scheduler_jobs
* alter_triggers
* compile_all
* update_id_sequences

**Dynamically Created Reporting Scripts**

After the database installation is complete, some reporting is needed to determine if evertyhing in the database was loaded successfully.  These custom created reports (in the root folder of the ZIP file) report any problems with database objects that were loaded during installation.

* Invalid Database Object
* JUnit Report

**Database Captured Installation Logs**

Log files are captured during database installation.  Almost all installation errors are captured in these log files.  As part of database installation, the installation log files are loaded into the "ODBCAPTURE_INSTALLATION_LOGS" table using the "odbcapture_installation_logs.cdl" script in the root folder of the ZIP file.  The "ODBCAPTURE_INSTALLATION_LOGS" table is dynamically created if necessary and can be pre-created if additional control is required.  The following reports, along with the "odbcapture_installation_logs.cdl" script, are custom generated as required in the root folder of the ZIP file.

* Install Status from Log File
* JUnit Report


### Misc. Specifications

**Filtered Caching of Data Dictionary**

There is considerable querying of the Data Dictionay tables when ODBCapture is generating build scripts.  In order to improve performance, a set of Data Dictionay tables is used to cache filtered data, reducing the taxation on the Data Dictionary tqables in the database.

**Data Capture**

Data capture includes a variety of issues.  One issue is the order of data loading.  Foreign key constraints must be complied with or disabled.  ODBCapture disables the Foreign key constraints.  Table triggers can incorrectly modify data during loading.  ODBCapture disables table triggers.  Binary data cannot be safely stored in build scripts.  HEX encoding is used for RAW data and Base64 encoding is used for BLOB encoding.  The data load build scripts are custom generated to include the HEX and Base64 decoding as required.

**Avoid errors granting permisions on a view that has errors**

If views are part of a complex depedency network, they can be very difficult to load in the correct sequence.  If view error occur during installation, it may not be possible to install the associated grants.  This problem has been resolved in ODBCapture using the [ORA-01720: "WORKAROUND" at ASK TOM](https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:43253832697675#2653213300346351987)



## Potential Roadblocks

There are several unexpected roadblocks to implementing accurate and complete database source code and configuration data.  The ability to directly capture all database source code and data can reveal shortcomings in existing policies and procedures.  When database changes are applied directly to production, it becomes laborsome to keep the source control system updated.  There are other political issues that pose potential roadblocks as well.


### Project Management

During initial implementation, learning curves and startup struggles result in longer lead times for database releases.  This is always problematic for project manangers and is an obvious potential roadblock.  However, there are other issues that can be surprising.

Many sophisticated databases contain a large amount of data.  Separating configuration data from other data can be a daunting task.  Project managers may be resistant to start the process of identifying and separating this configuration data.  This difficulty can be compounded in a lack of understanding of environment configurations for development, integration test, and QA.

Successful database release processing can include "fudging" releases when errors are found during the release.  Motivations are high to make the release work, rather than revert the release, find the error, and re-release.  Making the release work often results in missing updates to source control.  The project manager gets no benefit from identifying and removing these "fudges".  The ability to audit source control can expose these shortcomings in a release process that had been accepted as very successful.

If individual, throw-away, pluggable databases are given to developers, they can practice a great deal of independence.  This independence leads to creativity.  With the increased creativity, more options can be explored and proven by developers.  These additional options can become frustrating for project management due to the many moving parts.  A subtle resistance can begin to push against this newly found developer autonomy.

A more controlled development/delivery process can reduce error injection into production.  This reduction in release errors results in less need for superhuman effort to keep the production system running.  A troubleshooting superstar will have fewer opportunities to be a superstar.  That can result in a push-back against processes that improve the quality of the release process.


### Developers

Some of the obvious resisitance to new processes is the difficulty of learning and adjusting to them.  However, there are some other potential roadblocks that developers can have.

When the "gold standard" for database source control is in the development database, there can be a great resistance to massive database changes, also known as refactoring.  A new development processes that creates them from source code allows development databases to become disposable.  This idea of disposable development databases can me met with deep resistance from the developers.

When a shared development database is used, developers can get quite good at creating temporary test data for development of specific modules.  These test data sets can create become a unique niche for the developer in the development project.  Developer can be very hesitant to share these test data capabilities for fear of loosing that unique niche.


### Database Administrators

Possibly the biggest surprise is the push-back from the database administrators (DBAs).  A dialog regarding accurate and complete capture of source code and configuration data in the source code systems can alarm the DBAs.  DBAs are accustomed to cloning databases and masking production data to perpare for a "development system refresh".

*"..., copying production data for non-production purposes such as test and development is proliferating sensitive data, expanding the security and compliance boundary, and increasing the likelihood of data breaches."* [Oracle Data Masking and Subsetting](https://docs.oracle.com/en/database/oracle/oracle-database/19/dmksb/intro.html)

Cloning and masking can be consistent work on a periodic basis.  Implementation of complete source code and data configuration capture can be viewed and a threat to a steady work stream.

Another contentious issue for DBAs is the backup of the development and test systems.  These concerns are strongly supported by developers that consider the development database as the "gold standard" for database source code.  The ability to re-create complete development and test databases from source code negate the need for database backups.  This lack of need for database backups can be very difficult for DBAs to accept.
